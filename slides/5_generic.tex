\section{Generic Programming}

\begin{slide}{Pattern Functors}
\begin{haskell}
data U r         = U                 -- Empty constructor
data I r         = I r               -- Recursive call
data K a r       = K a               -- Constant
data (f :+: g) r = L (f r) | R (g r) -- Sums (Choice)
data (f :*: g) r = (f r) :*: (g r)   -- Products (Combine)
\end{haskell}

\begin{haskell}
type instance PF (Tree a) = K a                -- Leaf
                         :+: (I :*: K a :*: I) -- Node
\end{haskell}
\end{slide}

\begin{slide}{Merkle}
\begin{haskell}
type Merkle f = Fix (f :*: K Digest)

class Hashable f where
  hash :: f (Merkle g) -> Digest

instance ...

merkle ...
\end{haskell}
\end{slide}