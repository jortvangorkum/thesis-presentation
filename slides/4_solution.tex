\section{Solution}

\begin{slide}{Using Hash function}
A \textit{hash function} is a process of transforming input into an arbitrary fixed-size value (i.e., digest), where the same input always generates the same output

\begin{center}
\begin{minted}[escapeinside=!!]{text}
     5 
   /   \
  3     3       ->    1da16c7c48e429b4ad6e6c88d941d2bd
 / \   / \    
1  2   1  2                       !\textcolor{red}{Digest}!  
\end{minted}
\end{center}
\end{slide}

% \begin{slide}{Implementation Hash function}
% \begin{haskell}
% class Hashable a where
%   hash :: a -> Digest

% instance Hashable a => Hashable (Tree a) where
%   hash (Leaf x)     = concatDigest [hash "Leaf", hash x]
%   hash (Node l x r) = concatDigest [hash "Node", hash l, hash x, hash r]
% \end{haskell}
% \end{slide}

\begin{slide}{Storing the Digests}
A \textit{Merkle Tree} is a data structure which integrates the \textit{digests}, which represents the internal structure, within the data structure

\vspace*{0.4cm}
\begin{haskell}
data TreeH a = LeafH Digest a
             | NodeH Digest (TreeH a) a (TreeH a)


merkle :: Tree Int -> TreeH Int
merkle l@(Leaf x)     = LeafH (hash l) x
merkle b@(Node l x r) = NodeH (hash b) l' x r'
  where
    l' = merkle l
    r' = merkle r
\end{haskell}
\end{slide}

\begin{slide}{Efficiently updating the Input}
The \textit{Zipper} is a technique for keeping track of how the data structure is being traversed through

\begin{center}
\begin{minted}[escapeinside=!!]{text}
     !\textcolor{red}{5}!                            5     
   /   \                           \    
  3     3      ->      !\textcolor{red}{3}!            3    
 / \   / \            / \          / \  
1  2   1  2          1   2        1   2 
\end{minted}

\textbf{Go to the left Subtree of the Tree}
\end{center}
\end{slide}

\begin{slide}{Efficiently updating the Input}
Only the parent node digests needs to be updated. Which is more efficient than rehashing the entire tree.

Using the Zipper, we can traverse through the data structure and update the values where needed. And to restore the tree, we go up and while we are going up, we update the digests of the nodes.
\end{slide}

% \begin{slide}{Zipper - Left}


% \vspace*{0.4cm}
% \begin{haskell}
% left :: Loc a -> Loc a
% left (Node l x r, cs) = (l, (L r x):cs)
% \end{haskell}
% \end{slide}

% \begin{slide}{Zipper - Right}
% \begin{center}
% \begin{minted}[escapeinside=!!]{text}
%      !\textcolor{red}{5}!                    5     
%    /   \                 /           
%   3     3      ->       3          !\textcolor{red}{3}!  
%  / \   / \             / \        / \ 
% 1  2   1  2           1   2      1   2
% \end{minted}

% \vspace*{0.4cm}
% \begin{haskell}
% right :: Loc a -> Loc a
% right (Node l x r, cs) = (r, (R l x):cs)
% \end{haskell}
% \end{center}
% \end{slide}

% \begin{slide}{Zipper - Up}
% \begin{center}
% \begin{minted}[escapeinside=!!]{text}
%     5                        !\textcolor{red}{5}!        
%    /                       /   \           
%   3          !\textcolor{red}{3}!     ->     3     3      
%  / \        / \          / \   / \     
% 1   2      1   2        1  2   1  2   
% \end{minted}

% \vspace*{0.4cm}
% \begin{haskell}
% up :: Loc a -> Loc a
% up (t, (L r x):cs) = (Node l x r, cs)
% up (t, (R l x):cs) = (Node l x r, cs)
% \end{haskell}
% \end{center}
% \end{slide}